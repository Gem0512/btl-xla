<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Hiển thị ảnh</title>
    <style>
        input {
            width: 50px;
        }

        td {
            border: 1px solid;
        }
    </style>
</head>

<body>
    <style>
        .component {
            margin: 10px;
        }
    </style>
    <div class="component">
        <div>
            <div class="component">
                <input type="file" id="img_input" onclick="this.value=null" style="width: 400px;">
                <canvas id="histogram"></canvas>
            </div>
            <table style="width: 100%;">
                <tr>
                    <td>
                        <p>Âm bản</p>
                        <button onclick="makeNegative()">Âm bản</button>
                    </td>
                    <td>
                        <p>Phân ngưỡng</p>
                        <input type="number" id="threshold_input" placeholder="Nhập ngưỡng 0-255"
                            onchange="makeThreshold(parseInt(this.value))"step="2" min="0" max="255" style="width: 200px;">
                    </td>
                    <td>
                        <p>Biến đổi Log</p>
                        <button onclick="applyLogTransform()">Biến đổi Log</button>
                    </td>
                    <td>
                        <p>Biến đổi mũ</p>
                        <input type="number" id="gamma_input" placeholder="Nhập gamma" min="0" step="0.01"
                            style="width: 200px;">
                        <button onclick="applyPowerTransform()">Power</button>
                        <button onclick="applyRootTransform()">Root</button>
                    </td>
                    <td>
                        <p>Cân bằng xám</p>
                        <button onclick="equalizeHistorgram()">Cân bằng xám</button>
                    </td>
                    <td>
                        <p>Lọc laplacian biến thể</p>
                        <button onclick="filterLaplacianMutant()">Lọc laplacian biến thể</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>Lọc min</p>
                        <button onclick="filterMin()">Lọc min</button>
                    </td>
                    <td>
                        <p>Lọc max</p>
                        <button onclick="filterMax()">Lọc max</button>
                    </td>
                    <td>
                        <p>Lọc không gian (ma trận 3x3 [0,255])</p>
                        <button onclick="filterKhongGian()">Lọc không gian</button>
                        <table style="border: 1px solid;">
                            <tr>
                                <td><input id="matrixKhongGian00" /></td>
                                <td><input id="matrixKhongGian01" /></td>
                                <td><input id="matrixKhongGian02" /></td>
                            </tr>
                            <tr>
                                <td><input id="matrixKhongGian10" /></td>
                                <td><input id="matrixKhongGian11" /></td>
                                <td><input id="matrixKhongGian12" /></td>
                            </tr>
                            <tr>
                                <td><input id="matrixKhongGian20" /></td>
                                <td><input id="matrixKhongGian21" /></td>
                                <td><input id="matrixKhongGian22" /></td>
                            </tr>
                        </table>
                    </td>
                    <td>
                        <p>Lọc trung bình k giá trị, ngưỡng θ</p>
                        <button onclick="filterTrungBinhKGiaTri()">Lọc trung bình</button>
                        <input placeholder="Nhập k" id="trungbinhk" />
                        <input placeholder="Nhập θ" id="trungbinhphi" />
                    </td>
                    <td>
                        <p>Lọc trung vị </p>
                        <button onclick="filterMedian()">Lọc trung vị</button>
                    </td>
                    <td>
                        <p>Lọc laplacian</p>
                        <button onclick="filterLaplacian()">Lọc laplacian</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>Lọc Midpoint filter </p>
                        <button onclick="filterMidpoint()">Lọc Midpoint filter</button>
                    </td>
                    <td>
                        <p>Biên Roberts</p>
                        <input type="number" id="roberts_threshold" placeholder="Nhập threshold" onchange="roberts()"
                            min="0" step="1">
                    </td>
                    <td>
                        <p>Biên Prewitt </p>
                        <input type="number" id="prewitt_threshold" placeholder="Nhập threshold" onchange="prewitt()"
                            min="0" step="1">
                    </td>
                    <td>
                        <p>Biên Sobel </p>
                        <input type="number" id="sobel_threshold" placeholder="Nhập threshold" onchange="sobel()"
                            min="0" step="1">
                    </td>
                    <td>
                        <p>Tăng cường Laplacian</p>
                        <button onclick="increaseLaplacian()">Tăng cường laplacian</button>
                    </td>
                    <td>
                        <p>Tăng cường Laplacian biến thể</p>
                        <button onclick="increaseLaplacianMutant()">Tăng cường laplacian biến thể</button>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>Canny </p>
                        <button onclick="edgeCanny()">Canny</button>
                    </td>
                    <td>
                        <p>Otsu </p>
                        <button onclick="otsu()">Otsu</button>
                    </td>
                    <td>
                        <p>ISODATA</p>
                        <input type="number" id="isoData_deltaT" placeholder="Delta T (0.1 -> 255.0)"
                            onchange="isoData(parseFloat(this.value))" min="0" max="255" step="0.1"
                            style="width: 200px;">
                    </td>
                    <td>
                        <!-- <p>Background Symmetry algorithm (<span style="color: red;">Chưa hoàn thiện</span>)</p>
                        <input type="number" id="bsaPercent" placeholder="p% (0.01 -> 0.99)"
                            onchange="bsa(parseFloat(this.value))" min="0.01" max="0.99" step="0.01"
                            style="width: 200px;"> -->
                    </td>
                    <td>
                        <h2>Mã hóa và giải mã ảnh RLC</h2>

                        <input type="file" id="imageFileInput" accept="image/*" style="width: 300px;">
                        <br>
                        <textarea id="encodedTextArea" rows="5" cols="40"></textarea>
                        <button onclick="clickDecodeRLC()">Decode</button>
                        <br>
                        <canvas id="canvasRLC"></canvas>
                        <script>
                            const canvasRLC = document.getElementById('canvasRLC');
                            const ctxRLC = canvasRLC.getContext('2d');
                            const imageFileInput = document.getElementById('imageFileInput');
                            const encodedTextArea = document.getElementById('encodedTextArea');

                            // Xử lý sự kiện khi chọn file
                            imageFileInput.addEventListener('change', async function (event) {
                                const file = event.target.files[0];
                                const imageUrl = URL.createObjectURL(file);

                                // Tải hình ảnh từ file lên canvasRLC
                                const image = await loadImage(imageUrl);

                                // Lấy kích thước gốc của ảnh
                                const imageWidth = image.naturalWidth;
                                const imageHeight = image.naturalHeight;

                                // Cập nhật kích thước của canvasRLC
                                canvasRLC.width = imageWidth;
                                canvasRLC.height = imageHeight;

                                ctxRLC.drawImage(image, 0, 0, imageWidth, imageHeight);

                                // Lấy dữ liệu pixel từ hình ảnh trên canvasRLC
                                const imageData = ctxRLC.getImageData(0, 0, imageWidth, imageHeight).data;
                                // Mã hóa RLC và ghi vào textarea
                                const encodedImage = encodeRLC(imageData, imageWidth, imageHeight);
                                encodedTextArea.value = encodedImage;
                            });

                            // Xử lý sự kiện khi thay đổi textarea
                            function clickDecodeRLC() {
                                const encodedImage = encodedTextArea.value;

                                try {
                                    // Giải mã chuỗi RLC thành dữ liệu pixel
                                    const imageData1 = decodeRLC(encodedImage);
                                    const size = imageData1.slice(-2); // Lấy 2 phần tử cuối cùng của mảng
                                    const imageData = imageData1.slice(0, -2); // Tạo một mảng mới không chứa 2 phần tử cuối cùng
                                    const uint8ClampedArray = new Uint8ClampedArray(imageData.length);
                                    for (let i = 0; i < imageData.length; i++) {
                                        uint8ClampedArray[i] = imageData[i];
                                    }
                                    // Cập nhật kích thước của canvasRLC
                                    canvasRLC.width = size[0];
                                    canvasRLC.height = size[1];
                                    // Hiển thị dữ liệu pixel lên canvasRLC
                                    const decodedImageData = new ImageData(uint8ClampedArray, size[0], size[1]);
                                    ctxRLC.putImageData(decodedImageData, 0, 0);
                                } catch (error) {
                                    // Hiển thị thông báo lỗi
                                    alert('Đã xảy ra lỗi trong quá trình giải mã: ' + error.message);
                                }
                            }
                            // Hàm tải hình ảnh từ URL
                            function loadImage(url) {
                                return new Promise((resolve, reject) => {
                                    const image = new Image();
                                    image.onload = function () {
                                        resolve(image);
                                    };
                                    image.onerror = function () {
                                        reject(new Error('Không thể tải hình ảnh.'));
                                    };
                                    image.src = url;
                                });
                            }
                            // Hàm mã hóa RLC
                            function encodeRLC(imageData, width, height) {
                                let encodedData = '';
                                let tempData = imageData[0];
                                let tempCount = 1;

                                for (let i = 1; i < imageData.length; i++) {
                                    const currentData = imageData[i];

                                    if (currentData === tempData) {
                                        tempCount++;
                                    } else {
                                        encodedData += tempData + 'x' + tempCount + ' ';
                                        tempData = currentData;
                                        tempCount = 1;
                                    }
                                }

                                // Xử lý pixel cuối cùng
                                encodedData += tempData + 'x' + tempCount + ' ';
                                encodedData += width + 'x' + "1" + ' ';
                                encodedData += height + 'x' + "1";
                                return encodedData.trim();
                            }
                            // Hàm giải mã RLC
                            function decodeRLC(encodedData) {
                                const encodedPixels = encodedData.split(' ');
                                const imageData = [];

                                for (const encodedPixel of encodedPixels) {
                                    const [valueStr, countStr] = encodedPixel.split('x');
                                    const value = parseInt(valueStr);
                                    const count = parseInt(countStr);

                                    for (let i = 0; i < count; i++) {
                                        imageData.push(value);
                                    }
                                }

                                return imageData;
                            }

                            // Hàm so sánh hai mảng
                            function arraysEqual(a, b) {
                                return JSON.stringify(a) === JSON.stringify(b);
                            }
                        </script>
                    </td>
                    <td>
                        <h2>Mã hóa và giải mã ảnh Huffman</h2>

                        <input type="file" id="imageFileInputHuffman" accept="image/*" style="width: 300px;">
                        <br>
                        <p>chuỗi mã </p>
                        <input type="file" id="encodedTextAreaHuffman" style="width: 300px;"></input>
                        <p>bảng mã</p>
                        <input type="file" id="encodedTextAreaHuffmanTableJson" style="width: 300px;"></input>
                        <button onclick="clickDecodeHuffman()">Decode</button>
                        <br>
                        <canvas id="canvasHuffman"></canvas>
                        <script>
                            const canvasHuffman = document.getElementById('canvasHuffman');
                            const ctxHuffman = canvasHuffman.getContext('2d');
                            const imageFileInputHuffman = document.getElementById('imageFileInputHuffman');
                            const encodedTextAreaHuffman = document.getElementById('encodedTextAreaHuffman');
                            const encodedTextAreaHuffmanTableJson = document.getElementById('encodedTextAreaHuffmanTableJson');

                            // Xử lý sự kiện khi chọn file
                            imageFileInputHuffman.addEventListener('change', async function (event) {
                                const fileHuffman = event.target.files[0];
                                const imageUrlHuffman = URL.createObjectURL(fileHuffman);

                                // Tải hình ảnh từ file lên canvasRLC
                                const imageHuffman = await loadImage(imageUrlHuffman);

                                // Lấy kích thước gốc của ảnh
                                const imageWidthHuffman = imageHuffman.naturalWidth;
                                const imageHeightHuffman = imageHuffman.naturalHeight;

                                // Cập nhật kích thước của canvasRLC
                                canvasHuffman.width = imageWidthHuffman;
                                canvasHuffman.height = imageHeightHuffman;

                                ctxHuffman.drawImage(imageHuffman, 0, 0, imageWidthHuffman, imageHeightHuffman);

                                // Lấy dữ liệu pixel từ hình ảnh trên canvasRLC
                                const imageDataHuffman = ctxHuffman.getImageData(0, 0, imageWidthHuffman, imageHeightHuffman).data;
                                // Mã hóa RLC và ghi vào textarea
                                const encodedImageHuffmanRes = encodeHuffman(imageDataHuffman);
                                const encodedString = encodedImageHuffmanRes.encodedString + ' ' + imageWidthHuffman + ' ' + imageHeightHuffman;
                                const huffmanTable = encodedImageHuffmanRes.huffmanTable;

                                const encodedStringBlob = new Blob([encodedString], {
                                    type: 'text/plain'
                                });
                                const encodedStringUrl = URL.createObjectURL(encodedStringBlob);
                                const encodedStringLink = document.createElement('a');
                                encodedStringLink.href = encodedStringUrl;
                                encodedStringLink.download = 'encoded_string.txt';
                                encodedStringLink.click();

                                // Tải về file txt chứa bảng Huffman dưới dạng JSON
                                const huffmanTableBlob = new Blob([huffmanTable], {
                                    type: 'text/plain'
                                });
                                const huffmanTableUrl = URL.createObjectURL(huffmanTableBlob);
                                const huffmanTableLink = document.createElement('a');
                                huffmanTableLink.href = huffmanTableUrl;
                                huffmanTableLink.download = 'huffman_table.json';
                                huffmanTableLink.click();
                            });

                            function encodeHuffman(imageData) {
                                return encodeImageDataWithHuffman(imageData);
                            }

                            // Hàm để đọc tệp tin bằng FileReader và trả về một Promise
                            function readFile(file) {
                                return new Promise((resolve, reject) => {
                                    const reader = new FileReader();
                                    reader.onload = (event) => resolve(event.target.result);
                                    reader.onerror = (error) => reject(error);
                                    reader.readAsText(file, 'UTF-8');
                                });
                            }


                            async function clickDecodeHuffman() {
                                // Đọc nội dung của tệp tin mã hóa
                                const encodedFile = encodedTextAreaHuffman.files[0];
                                const encodeData = await readFile(encodedFile)
                                const [encodedString, width, height] = encodeData.split(" ");

                                // Đọc nội dung của tệp tin bảng Huffman
                                const huffmanTableFile = encodedTextAreaHuffmanTableJson.files[0];
                                const huffmanTableJson = await readFile(huffmanTableFile);

                                const huffmanTable = JSON.parse(huffmanTableJson);

                                // Tạo bảng đảo ngược từ bảng mã Huffman (để dễ dùng trong quá trình giải mã)
                                const reverseHuffmanTable = {};
                                for (const key in huffmanTable) {
                                    const code = huffmanTable[key];
                                    reverseHuffmanTable[code] = key.toString().padStart(3, '0');
                                }

                                // Thực hiện giải mã Huffman
                                let decodedString = '';
                                let currentCode = '';
                                let dataImage = [];
                                for (let i = 0; i < encodedString.length; i++) {
                                    currentCode += encodedString[i];
                                    if (reverseHuffmanTable[currentCode]) {
                                        decodedString += reverseHuffmanTable[currentCode];
                                        currentCode = '';
                                        if (decodedString.length == 3) {
                                            dataImage.push(parseInt(decodedString));
                                            decodedString = '';
                                        }
                                    }
                                }
                                // Push dataImage to canvasHuffman
                                const canvasHuffman = document.getElementById('canvasHuffman');
                                const ctxHuffman = canvasHuffman.getContext('2d');
                                const imageDataHuffman = ctxHuffman.createImageData(width, height);
                                imageDataHuffman.data.set(dataImage);
                                ctxHuffman.putImageData(imageDataHuffman, 0, 0);
                            }

                            class HuffmanNode {
                                constructor(value, frequency) {
                                    this.value = value;
                                    this.frequency = frequency;
                                    this.left = null;
                                    this.right = null;
                                }
                            }

                            // Tạo bảng tần số từ mảng đầu vào
                            function createFrequencyTable(array) {
                                const frequencyTable = {};
                                for (let i = 0; i < array.length; i++) {
                                    const value = array[i];
                                    if (frequencyTable[value]) {
                                        frequencyTable[value]++;
                                    } else {
                                        frequencyTable[value] = 1;
                                    }
                                }
                                return frequencyTable;
                            }

                            // Tạo cây Huffman từ bảng tần số
                            function buildHuffmanTree(frequencyTable) {
                                const priorityQueue = [];
                                for (const value in frequencyTable) {
                                    const frequency = frequencyTable[value];
                                    const node = new HuffmanNode(value, frequency);
                                    priorityQueue.push(node);
                                }
                                priorityQueue.sort((a, b) => a.frequency - b.frequency);

                                while (priorityQueue.length > 1) {
                                    const leftNode = priorityQueue.shift();
                                    const rightNode = priorityQueue.shift();
                                    const parentNode = new HuffmanNode(null, leftNode.frequency + rightNode.frequency);
                                    parentNode.left = leftNode;
                                    parentNode.right = rightNode;
                                    priorityQueue.push(parentNode);
                                    priorityQueue.sort((a, b) => a.frequency - b.frequency);
                                }

                                return priorityQueue[0];
                            }

                            // Tạo bảng mã Huffman từ cây Huffman
                            function createHuffmanTable(rootNode) {
                                const huffmanTable = {};

                                function traverse(node, path) {
                                    if (node.value !== null) {
                                        huffmanTable[node.value] = path;
                                    } else {
                                        traverse(node.left, path + '0');
                                        traverse(node.right, path + '1');
                                    }
                                }

                                traverse(rootNode, '');

                                return huffmanTable;
                            }

                            // Mã hóa mảng imageData thành chuỗi Huffman và tạo bảng mã
                            function encodeImageDataWithHuffman(imageData) {
                                const frequencyTable = createFrequencyTable(imageData);
                                const huffmanTree = buildHuffmanTree(frequencyTable);
                                const huffmanTable = createHuffmanTable(huffmanTree);
                                let encodedString = '';

                                for (let i = 0; i < imageData.length; i++) {
                                    encodedString += huffmanTable[imageData[i]];
                                }
                                return {
                                    encodedString: encodedString,
                                    huffmanTable: JSON.stringify(huffmanTable)
                                };
                            }
                        </script>
                    </td>
                </tr>
                           </table>
        </div>
        <canvas id="img_canvas"></canvas>
        <canvas id="img_canvas_new"></canvas>
    </div>
    <script>
        //#region pre-handle
        // docuument is ready
        var canvas = document.getElementById("img_canvas");
        var ctx = canvas.getContext("2d");

        var canvas_new = document.getElementById("img_canvas_new");
        var ctx_new = canvas_new.getContext("2d");

        var histogram_canvas = document.getElementById("histogram");
        var ctx_histogram_canvas = histogram_canvas.getContext("2d");

        histogram_canvas.width = 512;
        histogram_canvas.height = 500;

        document.getElementById('img_input').addEventListener('change', function (e) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx_new.clearRect(0, 0, canvas_new.width, canvas_new.height);
            ctx_histogram_canvas.clearRect(0, 0, ctx_histogram_canvas.width, ctx_histogram_canvas.height);

            var image = new Image();
            image.src = URL.createObjectURL(e.target.files[0]);

            image.onload = function () {
                canvas.width = image.width;
                canvas.height = image.height;
                ctx.drawImage(image, 0, 0);

                canvas_new.width = image.width;
                canvas_new.height = image.height;

                var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var data = imageData.data;
                var matrix = createMatrix(data, canvas.width, canvas.height);
                var histogramDataRating = getHistogramRating(getHistogramOfMatrix(matrix), data.length / 4);
                // Hiển thị histogram trên canvas histogram_canvas
                drawHistogram(histogramDataRating);
            };
        });

        function drawHistogram(histogramData) {
            var barWidth = Math.floor(histogram_canvas.width / histogramData.length);

            for (var i = 0; i < histogramData.length; i++) {
                var barHeight = histogramData[i] * 500;
                var x = i * barWidth;
                var y = histogram_canvas.height - barHeight;
                var barColor = "black";

                ctx_histogram_canvas.fillStyle = barColor;
                ctx_histogram_canvas.fillRect(x, y, barWidth, barHeight);
            }
        }
        //#endregion

        //#region default Transform
        function makeNegative() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;

            for (var i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i]; // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
            }

            ctx_new.putImageData(imageData, 0, 0);
        }

        function makeThreshold(threshold) {

            var canvas = document.getElementById("img_canvas");
            var ctx = canvas.getContext("2d");

            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;

            for (var i = 0; i < data.length; i += 4) {
                var gray = (data[i] + data[i + 1] + data[i + 2]) / 3;

                // Apply thresholding
                var binaryValue = gray > threshold ? 255 : 0;

                // Assign the thresholded value to each RGB channel
                data[i] = binaryValue;
                data[i + 1] = binaryValue;
                data[i + 2] = binaryValue;
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function applyLogTransform() {
            var canvas = document.getElementById("img_canvas");
            var ctx = canvas.getContext("2d");

            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;

            var c = 255; // Scaling constant

            for (var i = 0; i < data.length; i += 4) {
                var red = data[i];
                var green = data[i + 1];
                var blue = data[i + 2];

                // Calculate grayscale value
                var gray = (red + green + blue) / 3;

                // Apply log transform to grayscale value
                var transformedGray = c * (Math.log(gray + 1) / Math.log(256));

                // Set RGB channels to the transformed grayscale value
                data[i] = transformedGray;
                data[i + 1] = transformedGray;
                data[i + 2] = transformedGray;
            }

            ctx_new.putImageData(imageData, 0, 0);
        }

        function applyPowerTransform() {
            var canvas = document.getElementById("img_canvas");
            var ctx = canvas.getContext("2d");

            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;

            var c = 255; // Scaling constant
            var gamma = parseFloat(document.getElementById("gamma_input").value); // Gamma value

            for (var i = 0; i < data.length; i += 4) {
                var red = data[i];
                var green = data[i + 1];
                var blue = data[i + 2];
                var gray = (red + green + blue) / 3;
                var transformedGray = c * Math.pow(gray / 255, gamma);

                data[i] = transformedGray;
                data[i + 1] = transformedGray;
                data[i + 2] = transformedGray;
            }

            ctx_new.putImageData(imageData, 0, 0);
        }

        function applyRootTransform() {
            var canvas = document.getElementById("img_canvas");
            var ctx = canvas.getContext("2d");

            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;

            var c = 255; // Scaling constant
            var gamma = parseFloat(document.getElementById("gamma_input").value); // Gamma value

            for (var i = 0; i < data.length; i += 4) {
                var red = data[i];
                var green = data[i + 1];
                var blue = data[i + 2];
                var gray = (red + green + blue) / 3;
                var transformedGray = c * Math.pow(gray / 255, 1 / gamma);

                data[i] = transformedGray;
                data[i + 1] = transformedGray;
                data[i + 2] = transformedGray;
            }

            ctx_new.putImageData(imageData, 0, 0);
        }

        function equalizeHistorgram() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var histogramData = [];
            var equalizeHistogramData = [];
            for (var i = 0; i <= 255; i++) {
                histogramData.push(0);
            }
            for (var i = 0; i < data.length; i += 4) {
                histogramData[data[i]]++;
            }
            for (let i = 0; i < 256; i++) {
                var temp = 0;
                for (let j = 0; j <= i; j++) {
                    temp += histogramData[j]
                }
                equalizeHistogramData.push(temp);
            }
            for (var i = 0; i < data.length; i += 4) {
                var gray = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);

                // Apply thresholding
                var binaryValue = Math.round(equalizeHistogramData[gray] / (data.length / 4) * 255);

                // Assign the thresholded value to each RGB channel
                data[i] = binaryValue;
                data[i + 1] = binaryValue;
                data[i + 2] = binaryValue;
            }
            ctx_new.putImageData(imageData, 0, 0);
        }
        //#endregion

        //#region filter
        function increaseLaplacianMutant() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = matrixold[i][j] - getLaplacianMutantFilterPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterLaplacianMutant() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getLaplacianMutantFilterPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function increaseLaplacian() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = matrixold[i][j] - getLaplacianFilterPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterLaplacian() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getLaplacianFilterPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterMidpoint() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getMidpoint(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterMedian() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getMedianValue(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);

        }

        function filterTrungBinhKGiaTri() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getAVG_KValue(createNeibourhoodMatrix(matrixold, i, j, 3), matrixold[i][j])
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);

        }

        function filterKhongGian() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getValueOfStarFormula(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterMin() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var min = getMinOfMatrix(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = min;
                    data[x + 1] = min;
                    data[x + 2] = min;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function filterMax() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var max = getMaxOfMatrix(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = max;
                    data[x + 1] = max;
                    data[x + 2] = max;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }
        //#endregion

        //#region edge detection
        function edgeCanny() {
            var srcCanvas = document.getElementById('img_canvas');
            // srcCanvas.getContext('2d').drawImage(e.target, 0, 0);

            var src = cv.imread(srcCanvas); // load the image from canvas
            var dst = new cv.Mat();

            cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);

            cv.Canny(src, dst, 50, 100, 3, false); // You can try more different parameters
            cv.imshow('img_canvas_new', dst); // display the output to canvas

            src.delete(); // remember to free the memory
            dst.delete();
        }

        function laplacian() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var x1y = i + 1 == matrixold.length ? 0 : matrixold[i + 1][j];
                    var x_1y = i - 1 < 0 ? 0 : matrixold[i - 1][j];
                    var xy = matrixold[i][j]
                    var xy1 = j + 1 == matrixold[i].length ? 0 : matrixold[i][j + 1];
                    var xy_1 = j - 1 < 0 ? 0 : matrixold[i][j - 1];
                    var sumX = 0;
                    sumX += (x1y + x_1y - 2 * xy)
                    var sumY = 0;
                    sumY += (xy1 + xy_1 - 2 * xy)
                    var value = Math.sqrt(sumX + sumY);

                    value = value == NaN ? 0 : value;
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function roberts() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var xy = matrixold[i][j];
                    var x1y1 = (i + 1 == matrixold.length || j + 1 == matrixold[i].length) ? 0 : matrixold[i + 1][j + 1];
                    var x1y = (i + 1 == matrixold.length) ? 0 : matrixold[i + 1][j];
                    var xy1 = (j + 1 == matrixold[i].length) ? 0 : matrixold[i][j + 1];
                    var sumX = 0;
                    sumX += (xy - x1y1);
                    var sumY = 0;
                    sumY += (xy1 - x1y);
                    var threshold = parseInt(document.getElementById("roberts_threshold").value);
                    var value = Math.sqrt(sumX * sumX + sumY * sumY);
                    value = value > threshold ? 255 : 0;
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function sobel() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getSobelPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }

        function prewitt() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrixold = createMatrix(data, canvas.height, canvas.width);
            var x = 0;
            for (let i = 0; i < matrixold.length; i++) {
                for (let j = 0; j < matrixold[i].length; j++) {
                    var value = getPrewittPixel(createNeibourhoodMatrix(matrixold, i, j, 3))
                    data[x] = value;
                    data[x + 1] = value;
                    data[x + 2] = value;
                    data[x + 3] = 255;
                    x += 4;
                }
            }
            ctx_new.putImageData(imageData, 0, 0);
        }
        //#endregion

        //#region partition
        function bsa(percent) {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrix = createMatrix(data, canvas.width, canvas.height);
            var histogramDataRating = getHistogramRating(getHistogramOfMatrix(matrix), data.length / 4);
            var histogramDataRatingSum = histogramDataRating;
            var iMax = 0;
            var iMaxDoiXung = 0;
            var count = 0;
            var sum = 0;
            var tempSum = 0;
            for (var i = 0; i <= 255; i++) {
                if (histogramDataRating[i] > histogramDataRating[iMax])
                    iMax = i;
                if (i == 0) continue;
                histogramDataRatingSum[i] += histogramDataRatingSum[i - 1];
            }
            var virtual_threshold = 0;
            var tempabs = 1;
            if (iMax > 128)
                for (var i = iMax + 1; i <= 255; i++) {

                    if (Math.abs(histogramDataRating[iMax] * percent - histogramDataRating[iMax]) < tempabs) {
                        tempabs = Math.abs(histogramDataRating[iMax] * percent - histogramDataRating[iMax]);
                        virtual_threshold = i;
                    }
                }
            else
                for (var i = iMax - 1; i >= 0; i--) {

                    if (Math.abs(histogramDataRating[iMax] * percent - histogramDataRating[iMax]) < tempabs) {
                        tempabs = Math.abs(histogramDataRating[iMax] * percent - histogramDataRating[iMax]);
                        virtual_threshold = i;
                    }
                }
            var threshold = iMax + (iMax - virtual_threshold)
            makeThreshold(threshold);
        }

        function isoData(deltaT) {
            if (deltaT == null || deltaT == NaN) return;
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var matrix = createMatrix(data, canvas.width, canvas.height);

            if (deltaT == 0) return;
            if (matrix.length == 0) return;
            var t = 128;
            while (true) {

                var p = getHistogramRating(getHistogramOfMatrix(matrix), data.length / 4);
                var t1 = (getTrungBinhTichLuy(p, 0, Math.round(t)) / getTongTichLuy(p, 0, Math.round(t)) +
                    getTrungBinhTichLuy(p, Math.round(t) + 1, 255) / getTongTichLuy(p, Math.round(t) + 1, 255)) / 2;

                console.log(Math.abs(t1 - t));
                if (Math.abs(t1 - t) < deltaT) {
                    break;
                } else {
                    t = t1;
                }
            }
            makeThreshold(t);
        }

        function otsu() {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data;
            var histogramDataRating = [];
            var tongTichLuy = [];
            var equalizeHistogramData = [];
            var sumTichLuy = []
            var avgTichLuy = []
            var mG = 0;
            var phuongSai = 0;
            var t = 0;
            histogramDataRating = getHistogramRating(getHistogram(data), data.length / 4);
            for (var i = 0; i <= 255; i++) {
                mG += i * histogramDataRating[i];
                var sumTichLuyk = getTongTichLuy(histogramDataRating, 0, i);
                var avgTichLuyk = getTrungBinhTichLuy(histogramDataRating, 0, i);
                sumTichLuy.push(sumTichLuyk);
                avgTichLuy.push(avgTichLuyk);
            }

            for (var i = 0; i <= 255; i++) {
                var value = Math.pow(mG * sumTichLuy[i] - avgTichLuy[i], 2) / (sumTichLuy[i] * (1 - sumTichLuy[i]))
                if (phuongSai < value) {
                    phuongSai = value;
                    t = i;
                };
            }
            makeThreshold(t);
        }
        //#endregion

        //#region private func
        function getHistogramOfMatrix(matrix) {
            var histogramData = [];
            for (var i = 0; i <= 255; i++) {
                histogramData.push(0);
            }
            for (var i = 0; i < matrix.length; i++) {
                for (var j = 0; j < matrix[i].length; j++) {
                    histogramData[matrix[i][j]]++;
                }
            }
            return histogramData;
        }

        function getTongTichLuy(histogramDataRating, from, to) {
            var sumTichLuyk = 0;
            for (var j = from; j <= to; j++) {
                sumTichLuyk += histogramDataRating[j];
            }
            return sumTichLuyk;
        }

        function getTrungBinhTichLuy(histogramDataRating, from, to) {
            var avgTichLuyk = 0;
            for (var j = from; j <= to; j++) {
                avgTichLuyk += j * histogramDataRating[j];
            }
            return avgTichLuyk;
        }

        function getHistogram(data) {
            var histogramData = [];
            for (var i = 0; i <= 255; i++) {
                histogramData.push(0);
            }
            for (var i = 0; i < data.length; i += 4) {
                histogramData[data[i]]++;
            }
            return histogramData;
        }

        function getHistogramRating(histogramData, countPixel) {
            console.log(histogramData)
            var histogramDataRating = [];
            for (var i = 0; i <= 255; i++) {
                histogramDataRating[i] = histogramData[i] / countPixel;
            }
            return histogramDataRating;
        }

        function getSobelDirection(inputMatrix) {
            var sumX = 0;
            sumX += (inputMatrix[0][2] - inputMatrix[0][0]) / 2;
            sumX += (2 * inputMatrix[1][2] - 2 * inputMatrix[1][0]) / 4;
            sumX += (inputMatrix[2][2] - inputMatrix[2][0]) / 2;
            var sumY = 0;
            sumY += (inputMatrix[2][0] - inputMatrix[0][0]) / 2;
            sumY += (2 * inputMatrix[2][1] - 2 * inputMatrix[0][1]) / 4;
            sumY += (inputMatrix[2][2] - inputMatrix[0][2]) / 2;

            sumX /= 3;
            sumY /= 3;

            //get tan^-1 of sumX/sumY
            var grad = Math.atan(Math.abs(sumX / sumY));
            return grad;
        }

        function getGaussianPixel(inputMatrix) {
            var gaussianMatrix = [
                [2, 4, 5, 4, 2],
                [4, 9, 12, 9, 4],
                [5, 12, 15, 12, 5],
                [4, 9, 12, 9, 4],
                [2, 4, 5, 4, 2]
            ]
            var sum = 0;
            for (let i = 0; i < inputMatrix.length; i++) {
                for (let j = 0; j < inputMatrix[i].length; j++) {
                    sum += inputMatrix[i][j] * gaussianMatrix[i][j];
                }
            }
            return Math.round(sum / 159);
        }

        function getLaplacianMutantFilterPixel(inputMatrix) {
            var value = (inputMatrix[0][0] + inputMatrix[0][1] + inputMatrix[0][2] +
                inputMatrix[1][0] - 8 * inputMatrix[1][1] + inputMatrix[1][2] +
                inputMatrix[2][0] + inputMatrix[2][1] + inputMatrix[2][2]);
            return value;
        }

        function getLaplacianFilterPixel(inputMatrix) {
            var value = (inputMatrix[2][1] + inputMatrix[0][1] + inputMatrix[1][0] + inputMatrix[1][2] - 4 * inputMatrix[1][1]);
            return value;
        }

        function getSobelPixel(inputMatrix) {
            var sumX = 0;
            sumX += (inputMatrix[0][2] - inputMatrix[0][0]) / 2;
            sumX += (2 * inputMatrix[1][2] - 2 * inputMatrix[1][0]) / 4;
            sumX += (inputMatrix[2][2] - inputMatrix[2][0]) / 2;
            var sumY = 0;
            sumY += (inputMatrix[2][0] - inputMatrix[0][0]) / 2;
            sumY += (2 * inputMatrix[2][1] - 2 * inputMatrix[0][1]) / 4;
            sumY += (inputMatrix[2][2] - inputMatrix[0][2]) / 2;

            sumX /= 3;
            sumY /= 3;

            var deltaF = Math.sqrt(sumX * sumX + sumY * sumY);
            var threshold = parseInt(document.getElementById("sobel_threshold").value);

            return deltaF >= threshold ? 255 : 0;
        }

        function getPrewittPixel(inputMatrix) {
            var sumX = 0;
            sumX += (inputMatrix[0][2] - inputMatrix[0][0]) / 2;
            sumX += (inputMatrix[1][2] - inputMatrix[1][0]) / 2;
            sumX += (inputMatrix[2][2] - inputMatrix[2][0]) / 2;
            var sumY = 0;
            sumY += (inputMatrix[2][0] - inputMatrix[0][0]) / 2;
            sumY += (inputMatrix[2][1] - inputMatrix[0][1]) / 2;
            sumY += (inputMatrix[2][2] - inputMatrix[0][2]) / 2;

            sumX /= 3;
            sumY /= 3;

            var deltaF = Math.sqrt(sumX * sumX + sumY * sumY);
            var threshold = parseInt(document.getElementById("prewitt_threshold").value);

            return deltaF >= threshold ? 255 : 0;
        }

        function createMatrix(dataArray, height, width) {
            var h = 0;
            var w = 0;
            var response = [];
            var responseRow = [];
            for (var i = 0; i < dataArray.length; i += 4) {
                if (w < width) {
                    responseRow.push(dataArray[i])
                    w++;
                } else {
                    response.push(responseRow);
                    responseRow = []
                    responseRow.push(dataArray[i]);
                    w = 1;
                    h++;
                }
            }
            response.push(responseRow)
            return response;
        }

        function createNeibourhoodMatrix(dataMatrix, x, y, size) {
            var h = 0;
            var w = 0;
            var response = [];
            var partSize = (size - (size % 2)) / 2
            for (var i = x - partSize; i <= x + partSize; i++) {
                var responseRow = [];
                for (var j = y - partSize; j <= y + partSize; j++) {
                    if (i < 0 || j < 0 || i > dataMatrix.length || j > dataMatrix[x].length) responseRow.push(0);
                    else
                        try {
                            responseRow.push(dataMatrix[i][j]);
                        } catch {
                            console.log({
                                i,
                                j
                            })
                        }
                }
                response.push(responseRow);
            }
            return response;
        }

        function getMinOfMatrix(matrix) {
            var i = 0;
            var j = 0;
            var min = matrix[0][0];
            while (i < matrix.length) {
                while (j < matrix[i].length) {
                    if (min > matrix[i][j]) {
                        min = matrix[i][j];
                    }
                    j++;
                }
                i++;
                j = 0;
            }
            return min;
        }

        function getMaxOfMatrix(matrix) {
            var i = 0;
            var j = 0;
            var max = matrix[0][0];
            while (i < matrix.length) {
                while (j < matrix[i].length) {
                    if (max < matrix[i][j]) {
                        max = matrix[i][j];
                    }
                    j++;
                }
                i++;
                j = 0;
            }
            return max;
        }

        function getValueOfStarFormula(matrix) {
            var i = 0;
            var j = 0;
            var sumStar = 0;
            var sumMatrixFilter = 0;
            while (i < matrix.length) {
                while (j < matrix[i].length) {
                    var ipVal = parseInt(document.getElementById("matrixKhongGian" + i + j).value)
                    sumStar += matrix[i][j] * ipVal;
                    sumMatrixFilter += ipVal;
                    j++;
                }
                i++;
                j = 0;
            }
            if (sumMatrixFilter == 0) return 0;
            return sumStar / sumMatrixFilter;
        }

        function getAVG_KValue(matrix, current) {
            var k = parseInt(document.getElementById("trungbinhk").value);
            var phi = parseInt(document.getElementById("trungbinhphi").value);
            var l = []
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    l.push(matrix[i][j]);
                }
            }
            var sum = 0;
            l.sort().reverse();
            for (var i = 0; i < k; i++) {
                sum += l[i];
            }
            sum = sum / k;
            if (Math.abs(sum - current) > phi) return Math.round(sum);
            else return current;
        }

        function getMedianValue(matrix) {
            var k = parseInt(document.getElementById("trungbinhk").value);
            var phi = parseInt(document.getElementById("trungbinhphi").value);
            var l = []
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    l.push(matrix[i][j]);
                }
            }
            l.sort().reverse();
            return l[l.length % 2 == 0 ? l.length / 2 : (l.length + 1) / 2]
        }

        function getMidpoint(matrix) {
            var i = 0;
            var j = 0;
            var max = matrix[0][0];
            var min = matrix[0][0];
            while (i < matrix.length) {
                while (j < matrix[i].length) {
                    if (max < matrix[i][j]) {
                        max = matrix[i][j];
                    }
                    if (min > matrix[i][j]) {
                        min = matrix[i][j];
                    }
                    j++;
                }
                i++;
                j = 0;
            }
            return (max + min) / 2;
        }
        //#endregion
    </script>
    <script src="opencv.js" type="text/javascript"></script>

</body>

</html>